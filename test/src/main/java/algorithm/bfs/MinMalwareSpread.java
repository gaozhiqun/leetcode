package algorithm.bfs;

import javax.management.Query;
import java.util.*;

/**
 * @author zhiqungao@tencent.com
 * @date 2021/10/20 下午2:11
 */
public class MinMalwareSpread {
    public static void main(String[] args) {
        MinMalwareSpread minMalwareSpread = new MinMalwareSpread();
        System.out.println(minMalwareSpread.minMalwareSpread(new int[][]{
                {1, 1, 0, 0}, {1, 1, 1, 0}, {0, 1, 1, 1}, {0, 0, 1, 1}
        }, new int[]{0, 1}));
    }

    public int minMalwareSpread(int[][] graph, int[] initial) {
        int m = graph.length;
        int[] clean = new int[m];
        List[] infectedBy = new List[m];
        for (int i = 0; i < m; i++) {
            infectedBy[i] = new ArrayList();
        }
        for (int i : initial) {
            clean[i] = 1;
        }
        for (int i : initial) {
            Set<Integer> seen = new HashSet<>();
            dfs(graph, clean, i, seen);
            for (int v : seen) {
                infectedBy[v].add(i);
            }
        }
        int[] contributions = new int[m];
        for (List<Integer> list : infectedBy) {
            if (list.size() == 1) {
                ++contributions[list.get(0)];
            }
        }
        Arrays.sort(initial);
        int ans = initial[0], score = -1;
        for (int i : initial) {
            if (contributions[i] > score) {
                score = contributions[i];
                ans = i;
            }
        }
        return ans;
    }

    public void dfs(int[][] graph, int[] clean, int cur, Set<Integer> seen) {
        for (int i = 0; i < graph[cur].length; i++) {
            if (graph[cur][i] == 1 && clean[i] == 0 && !seen.contains(i)) {
                seen.add(i);
                dfs(graph, clean, i, seen);
            }
        }
    }
}
